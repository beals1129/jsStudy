<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- <script>
        function taskA(a,b,callback) {
            setTimeout(()=> {
                const res = a+ b //지역상수
                callback(res);
            },3000)
        }

        function taskB (a , callback) {
            setTimeout(()=> {
                const res = a+1;
                callback(res);
            },1000)
        }
        
        function taskC (a, callback) {
            setTimeout(() => {
                const res = a+1;
                callback(res);
            },2000)
        }

        taskA(4,5,(a_res)=>{
            console.log("A Result:" , a_res)
            taskB(a_res, (b_res) => {
                console.log("B Result", b_res)
                taskC(b_res, (c_res)=> {
                    console.log("C Result", c_res)
                })
            })
        })
        //callback 이 많아지는 콜백지옥이 일어날 수 있다.

        


        console.log("실행")

    </script> -->
    <script>
        //callback 대신 resolve, reject 를 받아서 사용
        function taskA(a,b) {
            return new Promise((resolve, reject) => {
                setTimeout(()=> {
                    const res = a+ b //지역상수
                    resolve(res);
                },3000)
            })
            
        }
        function taskB (a) {
            return new Promise((resolve , reject ) => {
                setTimeout(()=> {
                    const res = a+1;
                    resolve(res);
            },1000)
            })

        }
        
        function taskC (a) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    const res = a+1;
                    resolve(res);
                },2000)
            })

        }

        // taskA(4,1).then((a_res) => {
        //     console.log("A result : " , a_res);
        //     taskB(a_res).then((b_res) => {
        //         console.log("B result : " , b_res);
        //         taskC(b_res).then((c_res) => {
        //             console.log("C result : " , c_res);
        //         })
        //     })
        // })

        // 간단하게  than 메소드사용 계속 붙이는 것을 > than chaining > 프라미스 체이닝
        taskA(4,1).then((a_res) => {
            console.log("A result : " , a_res);
            return taskB(a_res);
        }).then((b_res)=> {
            console.log("B result : " , b_res);
            return taskC(b_res);
        }).then((c_res) => {
            console.log("C result : " , c_res);
        })

        //이걸 두개로 나눌 수도 있음

        const bPromiseResult = taskA(4,1).then((a_res) => {
            console.log("A result : " , a_res);
            return taskB(a_res);
        })

        bPromiseResult.then((b_res)=> {
            console.log("B result : " , b_res);
            return taskC(b_res);
        }).then((c_res) => {
            console.log("C result : " , c_res);
        })
    </script>
</body>
</html>